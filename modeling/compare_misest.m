function compare_misest(group)%SAtb Function COMPARE_MISEST% - Compares performance btw ideal and misestimting recievers for HS vs Th% - Receivers can have iparams mismatched to eparams. Uses fetch_playbacks%   6/1/08%%Based on siggy.m, compare_params.m%% Implementation of classic SDT util function using NORMCDF (whereas older% SigBE program uses Wieble fn)% Implementation of hotspot util using NORMPDF% Comparision of curves and payoff accrual%% Think: avian predation on cryptic butterflys, avoid aposematics.%%    PDF1 - green (cryptics: CD/MD), mean=0;S+%    PDF2 - blue (aposematics:FA/CR) = S-%    - Eat everything to LEFT of t%    - Peak shift LEFT of muSplus.%    ...normcdf=-inf to x, so CD=normcdf, MD=1-normcdf%       Classic util will tend to be higher on S- side b/c CDF vales are near one as approach +INF.%%CHANGE LOG% Removed incorrect use of d' in fetch_playbacks for distn of signal2.% 1/1/09 - fixed incorrect payoff assignment when S+>S- in FetchPlaybacks% 9/21/12 - added settings for calls to EVALUATE, added set-able outputfilepath% 1/17/16 - Renamed var "a" to "ac" (for accuracy) about line 714 (Main, "settings for EVALUATE"). %           As "a" the code was inadvertantly overwriting global FA cost.%           No change in results because that late change to a didn't effect later interations.% 2/8/16 - Fixed plotting (broke after some ML update): suss & pass fig.Number%%TO DO:% - some out of range errors when x_range not big enough.% - use new HS lineaer scaling routine (see compare_params2.m)?%%%%%%%%%%%%%%%%%%%clc;%clear ML command windowrunflag=1;group=num2str(group) %incase user enters just a numberswitch group %controls which group of param sets to run        case 'osm'        outputfilepath=outcomespecificbias %20150401             case 'misc'        outputfilepath=tvar_v_brate %20160208            case 'estp' %estimating perceivers' internal parameter values        %outputfilepath=otd_misest        outputfilepath=utd_misest    case 'sig'      sap2bl%         sap2pay%         sap2br%          sap2si%          sap1%         sig3p2            case 'util'        %zm_accurate        %zm_misest%         outputfilepath=scores %bias vs acc%         outputfilepath=misest_re_sap2brate        outputfilepath=misest_re_utilms            case 'vary'         %outputfilepath=vary_sim_sap2br         %outputfilepath=vary_sim_otd_bsl         %outputfilepath=vary_sim_UTD_libbrate         outputfilepath=vary_sim_m1_consbrate    case 'sap1'        outputfilepath=sap1_rangeshift%         sap1pay            otherwise        disp('Group not recognized.')        runflag=0;endif runflag==1    main(outputfilepath)endend %compare params%% SCENARIO DEFINITION FUNCTIONSfunction outputfilepath=tvar_v_brate %set of params to compare% 20160208: compare d',c for base rate vs varTarget manipsglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 1000;iterations = 10;outputfilepath='/Users/spencer/Downloads';h=[10 10 10]; %h cd of mimic, benem=[-3 -3 -3]; %m md of mimic, costa=[-10 -10 -10]; %a fa of model, costj=[10 10 10]; %j cr of model, benealpha=[.75 .5 .75]; %P[signal 1]muSplus=[7.5 7.5 7.5]; %mean of signal 1 (S+)var1=[1.5 3 1.5]; %variance of signal 1muSminus=[4.5 4.5 4.5]; %mean sig 2var2=[1.5 1.5 1.5]; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction outputfilepath=outcomespecificbias %set of params to compare% 20140401: For examining the effects of parameter mis-estimates on outcome-specific% bias/motivation patterns.% ** ?FOR THIS TO BE INFORMATIVE, WOULD NEED THE DIFFERENT MISEST TO HAVE SAME THREHOLD?%-eg, misest of OTD baseline scenario's base rate vs MD or MD+FA or MD+CD payoffs.% - ah, crud. This isn't going to reveal differential response trial-by-trial contingent on feedback, % it's the same threshold regardless of which parameter is misestimated.global h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 1000;iterations = 1;outputfilepath='/Users/spencer/Coding/Matlabber/my_m-files/SAlab/experiments/model_osm'h=[100 100]; %h cd of mimic, benem=[-10 -10]; %m md of mimic, costa=[-120 -120]; %a fa of model, costj=[100 100]; %j cr of model, benealpha=[.5 .25]; %P[signal 1]muSplus=[7.5 7.5]; %mean of signal 1 (S+)var1=[1.5 1.5]; %variance of signal 1muSminus=[4.5 4.5]; %mean sig 2var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction outputfilepath=otd_misest %set of params to compare% For estimating perceivers' internal parameter values, 4/14/14%-misest of OTD baseline scenario's base rate.global h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 1000;iterations = 10;outputfilepath='/Users/spencer/Coding/Matlabber/my_m-files/SAlab/experiments/model_estparams'h=[100 100]; %h cd of mimic, benem=[-10 -100]; %m md of mimic, costa=[-120 -120]; %a fa of model, costj=[100 100]; %j cr of model, benealpha=[.5 .5]; %P[signal 1]muSplus=[7.5 7.5]; %mean of signal 1 (S+)var1=[1.5 1.5]; %variance of signal 1muSminus=[4.5 4.5]; %mean sig 2var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction outputfilepath=utd_misest %set of params to compare% For estimating perceivers' internal parameter values, 4/14/14%-misest of UTD lib-brate scenario's base rate.global h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 1000;iterations = 10;outputfilepath='/Users/spencer/Downloads'h=[10 10]; %h cd of mimic, benem=[-3 -10]; %m md of mimic, costa=[-10 -10]; %a fa of model, costj=[10 10]; %j cr of model, benealpha=[.78 .78]; %P[signal 1]muSplus=[7 7]; %mean of signal 1 (S+)var1=[1.5 1.5]; %variance of signal 1muSminus=[5 5]; %mean sig 2var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction outputfilepath=misest_re_utilms %set of params to compare% For util ms, 2/17/14%-scenario 1 = sap2 low base rate, cons payoffs%-scenario 2 = liberal payoff misest, at same low brate,% to really accentuate the ultimate differce in accumulation of pts vs% earlier version of this figure based on misest_re_sap2brateglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 1000;iterations = 10;outputfilepath='/Users/spencer/Coding/Matlabber/my_m-files/SAlab/experiments/model_utilizing_SDT'h=[10 10]; %h cd of mimic, benem=[-1 -15]; %m md of mimic, costa=[-15 -1]; %a fa of model, costj=[10 10]; %j cr of model, benealpha=[.25 .25]; %P[signal 1], S+ = mis est of 0.57 -> neutral bias muSplus=[7 7]; %mean of signal 1 (S+)var1=[1.5 1.5]; %variance of signal 1muSminus=[5 5]; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction outputfilepath=misest_re_sap2brate %set of params to compare% For util ms, 9/21/12%-scenario 1 = sap2 baserate%-scenario 2 = brate over est re scen1, to produce neutral bias.global h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 1000;iterations = 10;outputfilepath='/Users/spencer/Coding/Matlabber/my_m-files/SAlab/experiments/model_utilizing_SDT'h=[10 10]; %h cd of mimic, benem=[-3 -3]; %m md of mimic, costa=[-7 -7]; %a fa of model, costj=[10 10]; %j cr of model, benealpha=[.25 .57]; %P[signal 1], S+ = mis est of 0.57 -> neutral bias muSplus=[7 7]; %mean of signal 1 (S+)var1=[1 1]; %variance of signal 1muSminus=[5 5]; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction sig3p2 %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 100;iterations = 10;h=[10 10 10]; %h cd of mimic, benem=[-10 -10 -10]; %m md of mimic, costa=[-8 -8 -8]; %a fa of model, costj=[10 10 10]; %j cr of model, benealpha=[.5 .5 .47]; %P[signal 1], S+muSplus=[7 7 7]; %mean of signal 1 (S+)var1=[1 1 1]; %variance of signal 1muSminus=[6 6.3 6]; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction outputfilepath=sap1_rangeshift %set of params to compareoutputfilepath='/Users/spencer/Coding/Matlabber/my_m-files/SAlab/experiments/sap1_catsd/sap1_program'global h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 10000;iterations = 10;h=[0 0]; %h cd of mimic, benem=[-3 -3]; %m md of mimic, costa=[-6 -6]; %a fa of model, costj=[10 10]; %j cr of model, benealpha=[.5 .5]; %P[signal 1], S+muSplus=[7 8]; %mean of signal 1 (S+)var1=[1.5 1.5]; %variance of signal 1muSminus=[5 6]; %mean sig 2, usu S- to right of S+var2=[1.5 1.5]; %variance of signal 1checkerr%Parameter Error Checkingend %parameter set def'nfunction sap1pays %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 100;iterations = 10;h=[1 0 1 1 1]; %h cd of mimic, benem=[-3 -3 -1 -3 -3]; %m md of mimic, costa=[-6 -6 -6 -10]; %a fa of model, costj=[10 10 10 10 15]; %j cr of model, benealpha=[.5 .5 .5 .5]; %P[signal 1], S+muSplus=[7 7 7 7]; %mean of signal 1 (S+)var1=[1 1 1 1]; %variance of signal 1muSminus=[5 5 5 5]; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction zm_accurate %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 100;iterations = 10;h=[1 1]; %h cd of mimic, benea=[-1 -1]; %a fa of model, costm=[-100 -100]; %m md of mimic, costj=[1 1]; %j cr of model, benealpha=[.5 .05]; %P[signal 1], S+muSplus=[7 7]; %mean of signal 1 (S+)var1=[1 1]; %variance of signal 1muSminus=[5 5]; %mean sig 2, usu S- to right of S+var2=[1 1]; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction zm_misest %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 100;iterations = 10;h=[1 1]; %h cd of mimic, benea=[-1 -1]; %a fa of model, costm=[-100 -100]; %m md of mimic, costj=[1 1]; %j cr of model, benealpha=[.05 .5]; %P[signal 1], S+muSplus=[7 7]; %mean of signal 1 (S+)var1=[1 1]; %variance of signal 1muSminus=[5 5]; %mean sig 2, usu S- to right of S+var2=[1 1]; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction tr01 %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 100;iterations = 10;h=[1 1]; %h cd of mimic, benea=[-.5 -.5]; %a fa of model, costm=[-100 -1]; %m md of mimic, costj=[.5 .5]; %j cr of model, benealpha=[.1 .1]; %P[signal 1], S+muSplus=[7 7]; %mean of signal 1 (S+)var1=[1.5 1.5]; %variance of signal 1muSminus=[5 5]; %mean sig 2, usu S- to right of S+var2=[1.5 1.5]; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction sap2pay %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 1000;iterations = 10;h=[10 10 10]; %h cd of mimic, benem=[-15 -15 -3]; %m md of mimic, costa=[-1 -1 -7]; %a fa of model, costj=[10 10 10]; %j cr of model, benealpha=[.5 .5 .5]; %P[signal 1], S+muSplus=[7 7 7]; %mean of signal 1 (S+)var1=[1 1.5 1]; %variance of signal 1muSminus=[5 5 5]; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction sap2bl %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 1000;iterations = 10;h=[10 10]; %h cd of mimic, benem=[-3 -3]; %m md of mimic, costa=[-7 -7]; %a fa of model, costj=[10 10]; %j cr of model, benealpha=[.5 .5]; %P[signal 1], S+muSplus=[7 7]; %mean of signal 1 (S+)var1=[1 3]; %variance of signal 1muSminus=[5 5]; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction sap2si %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 100;iterations = 10;h=[10 10 10]; %h cd of mimic, benem=[-3 -3 -3]; %m md of mimic, costa=[-7 -7 -7]; %a fa of model, costj=[10 10 10]; %j cr of model, benealpha=[.5 .5 .5]; %P[signal 1], S+muSplus=[7 7 7]; %mean of signal 1 (S+)var1=[1 1 1.5]; %variance of signal 1muSminus=[6 6 6]; %mean sig 2, usu S- to right of S+var2=[1 1.5 1]; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction outputfilepath=vary_sim_sap2br %sxb for sap2 baseline scenarioglobal h j a m muSplus muSminus var1 var2 alpha%To plot relationship of optimal bias for decreasing d' at given pay,base rate% varies d' over several steps (payoff, baserate = constant)% Successively lower d' by increase S+ & S- variance in sync.% - this code varies base rate.playbacks = 100;iterations = 10;reps=12;outputfilepath='/Users/spencer/Coding/Matlabber/my_m-files/SAlab/experiments/ari_OTDSBR/otd_program/data';%%%Mis-est this to get subopt thresholds alpha=linspace(0.25,.5,reps); %get the lower half, 0.5 = accurate%  alpha=linspace(0.5,1,reps); %get the upper half, 0.5 = accurate%Vary this by hand to match values on optimal sxb line. values come from linespace 1-5 in 10 stepsvar1=ones(1,reps)*1 ; %P[signal 1], S+ 1-5 h=ones(1,reps)*10; %h cd of mimic, benea=ones(1,reps)*-7; %a fa of model, costm=ones(1,reps)*-3; %m md of mimic, costj=ones(1,reps)*10; %j cr of model, benemuSplus=ones(1,reps)*7; %mean of signal 1 (S+)muSminus=ones(1,reps)*5; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction outputfilepath=vary_sim_UTD_libbrate %set of params to compare% Determine optimal model values for sensitivity values varying from high to low% by looking at reps #steps of increasing SIM varianceglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runoutputfilepath='/Users/spencer/Coding/Matlabber/my_m-files/SAlab/experiments/catsd3_utd/utd_program/data';playbacks = 1000;iterations = 10;reps=20; %# steps of variation% Apply OTD baseline scenario valuesh=ones(1,reps)*10; %h cd of mimic, benem=ones(1,reps)*-3; %m md of mimic, costa=ones(1,reps)*-10; %a fa of model, costj=ones(1,reps)*10; %j cr of model, benealpha=ones(1,reps)*.78; %P[signal 1], S+muSplus=ones(1,reps)*7; %mean of signal 1 (S+)var1=linspace(1.5,4.5,reps); %variance of signal 1; linspace creats the range.% Here, were varying SIM variance from 1.5 (envir, objective) to 2.5 (a large misest) std units in reps equal-sized steps.muSminus=ones(1,reps)*5; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction outputfilepath=vary_sim_otd_bsl %set of params to compare% Determine optimal model values for sensitivity values varying from high to low% by looking at reps #steps of increasing SIM varianceglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runoutputfilepath='/Users/spencer/Coding/Matlabber/my_m-files/SAlab/experiments/ari_OTDSBR/otd_program/data';playbacks = 1000;iterations = 10;reps=20; %# steps of variation% Apply OTD baseline scenario valuesh=ones(1,reps)*100; %h cd of mimic, benem=ones(1,reps)*-10; %m md of mimic, costa=ones(1,reps)*-120; %a fa of model, costj=ones(1,reps)*100; %j cr of model, benealpha=ones(1,reps)*.5; %P[signal 1], S+muSplus=ones(1,reps)*7.5; %mean of signal 1 (S+)var1=linspace(1.5,4.5,reps); %variance of signal 1; linspace creats the range.% Here, were varying SIM variance from 1.5 (envir, objective) to 2.5 (a large misest) std units in reps equal-sized steps.muSminus=ones(1,reps)*4.5; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction outputfilepath=vary_sim_m1_consbrate %set of params to compare% Determine optimal model values for sensitivity values varying from high to low% by looking at reps #steps of increasing SIM varianceglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runoutputfilepath='/Users/spencer/Coding/Matlabber/my_m-files/SAlab/experiments/marathon/m1_program/data';playbacks = 1000;iterations = 10;reps=20; %# steps of variation% Apply OTD baseline scenario valuesh=ones(1,reps)*10; %h cd of mimic, benem=ones(1,reps)*-25; %m md of mimic, costa=ones(1,reps)*-10; %a fa of model, costj=ones(1,reps)*10; %j cr of model, benealpha=ones(1,reps)*.25; %P[signal 1], S+muSplus=ones(1,reps)*7.5; %mean of signal 1 (S+)var1=linspace(1.5,10.5,reps); %variance of signal 1; linspace creats the range.% Here, were varying SIM variance from 1.5 (envir, objective) to 2.5 (a large misest) std units in reps equal-sized steps.muSminus=ones(1,reps)*4.5; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction sap2br %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 1000;iterations = 10;h=[10 10] %h cd of mimic, benem=[-3 -3]; %m md of mimic, costa=[-7 -7]; %a fa of model, costj=[10 10]; %j cr of model, benealpha=[.25 .25]; %P[signal 1], S+muSplus=[7 7]; %mean of signal 1 (S+)var1=[1 2]; %variance of signal 1muSminus=[5 5]; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction scores1 %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 100;iterations = 10; h=[10 10]; %h cd of mimic, benea=[-7  -7]; %a fa of model, costm=[-3 -3]; %m md of mimic, costj=[10 10]; %j cr of model, bene alpha=[.5 .999]; %P[signal 1], S+muSplus=[7 7]; %mean of signal 1 (S+)var1=[1 1]; %variance of signal 1muSminus=[5 5]; %mean sig 2, usu S- to right of S+var2=[1 1]; %variance signal 2 checkerr%Parameter Error Checking end %parameter set def'n function outputfilepath=scores %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks reps%Init params as array of values for each manipulation runplaybacks = 100;iterations = 10;outputfilepath='/Users/spencer/Coding/Matlabber/my_m-files/SAlab/experiments/sxb_ms'reps=10;mod=linspace(5,.1,reps);h=ones(1,reps)*1.*mod; %h cd of mimic, benem=ones(1,reps)*-1.*mod; %m md of mimic, costa=ones(1,reps)*-.5; %a fa of model, costj=ones(1,reps)*.5; %j cr of model, benealpha=ones(1,reps)*.5; %P[signal 1], S+muSplus=ones(1,reps)*7; %mean of signal 1 (S+)var1=ones(1,reps)*1; %variance of signal 1muSminus=ones(1,reps)*5; %mean sig 2, usu S- to right of S+var2=var1; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction utilizing3 %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation runplaybacks = 100;iterations = 10;h=[2 2]; %h cd of mimic, benea=[-1 -1]; %a fa of model, costm=[-2 -2]; %m md of mimic, costj=[1 1]; %j cr of model, benealpha=[.5 .5]; %P[signal 1], S+muSplus=[7 7]; %mean of signal 1 (S+)var1=[1.5 3]; %variance of signal 1muSminus=[5 5]; %mean sig 2, usu S- to right of S+var2=[1.5 3]; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'n%% MAIN FUNCTIONSfunction demo %set of params to compareglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks%Init params as array of values for each manipulation run,%where array defn = [ideal misest [misest...]]. Ideal="e-params" (external world), misest="i-params" (internal representation).%Identical values == no misestimation. First set=e-params. Can be followed%by as many i-param sets as you like.playbacks = 160;iterations = 10;% 10	10	10	10% -7	-1	-7	-7% -3	-15	-3	-3% 10	10	10	10% 0.5	0.5	0.25	0.5h=[10]; %h cd of mimic, benea=[-15]; %a fa of model, costm=[-15]; %m md of mimic, costj=[10]; %j cr of model, benealpha=[.5]; %P[signal 1], S+muSplus=[7]; %mean of signal 1 (S+)var1=[1.5]; %variance of signal 1muSminus=[5]; %mean sig 2, usu S- to right of S+var2=[1.5]; %variance signal 2checkerr%Parameter Error Checkingend %parameter set def'nfunction checkerrglobal h j a m muSplus muSminus var1 var2 alpha directiondirection='left'; %set a default direction of hits (left of threshold)for i=1:length(h)    if (h(i)<j(i) || j(i)<a(i) || h(i)<a(i))        disp('Error: Double-check payoff values')    end    if(muSplus>muSminus)        direction='right';        %disp('Note: S- to left of S+')    endendend %check errorsfunction main(outputfilepath)global h j a m muSplus muSminus var1 var2 alpha iterations playbacks reps %settings globalsglobal roundby x_range numsets hs_response_ara measures performance samplesglobal cl_ara pCD pFA S threshold maxhotspotloc response %implement_params globalsif nargin==0    outputfilepath=('/Users/spencer/Downloads')endrand('state',sum(100*clock)) %Reset random seed to arbitrary number to avoid sequence repitition in fetch_playbacksroundby=50;roundby=10;xstep=.02; %controls sensory acuity after a fashionxstep=.1; %controls sensory acuity after a fashionx_range=rounder(-15:xstep:30,roundby); %Clean out some very small numbers, round to .02.% x_range=1:xstep:11; %overwrite above xrange%Turn plotting on=1 off=0sigplot=1;rocplot=0;payplot=1;performplot=0; %not working: needs access to CDs, etc, at each iteration%init plot windowsif sigplot>0    fig=figure;    sigplot=fig.Number;    hold on; zoom onendif rocplot>0    fig=figure;    rocplot=fig.Number;    hold on; %zoom onendif iterations>0    if payplot>0        fig=figure;        payplot=fig.Number;        hold on; zoom on    end    if performplot>0         fig=figure;        performplot=fig.Number;       hold on; zoom on    endend%init structures that need to persist over param setsnumsets=length(muSplus);measures=ones(numsets,5+2+4)*NaN; %cols=P[CD] P[FA] Slope Tloc HSloc +6 performance measureshs_response_ara=ones(numsets,length(x_range))*NaN;    implement_params(h(1),j(1),a(1),m(1),muSplus(1),muSminus(1),var1(1),var2(1),alpha(1)); %get ideal characteristics paramsets    actual_th_util=cl_ara;    received_th_util=1:numsets; for i=1:numsets %loop for each series of param settings.   thr_index=implement_params(h(i),j(i),a(i),m(i),muSplus(i),muSminus(i),var1(i),var2(i),alpha(i)); %get ideal characteristics paramsets   received_th_util(i)=actual_th_util(thr_index); % the util a misestimating reciever will actually get (vs. what it thinks it will get)            %Reciever's anticipated CD,FA given criteria.    %Criteria are set using misestiatmed params for param set 2...    measures(i,1:5)=[pCD pFA S threshold maxhotspotloc]; %Log results: optimal given reciever's settings    hs_response_ara(i,:)=response;            %Update plots    if sigplot>0        plotsignals(sigplot,i)    end    if rocplot>0        plotroc(rocplot,i)    endend %for-loop of param settings.if iterations>0    fetch_playbacks %run signal reception simulations    %Compare payoff accruals. On for-loops >1, uses "mistestimated" i-params for    %reception of signals and payoffs generated according to e-params (the same exact signals used in 1st loop).end %if fetch_playbacks calledfor i=1:numsets %loop for each series of param settings.    if iterations>0        if payplot>0 %Update plots            plotpayoffs(payplot,i) %i counter used to select color for param set        end        if performplot>0            plotperformance(performplot,i)        end        %Could compute mean over iterations, but will do grand ttl for now.        CDs=length(find(performance(:,7,:,i)==1)); %grand ttl #CDs over all iterations        FAs=length(find(performance(:,7,:,i)==2)); %grand ttl #FAs over all iterations        MDs=length(find(performance(:,7,:,i)==3)); %grand ttl #MDs over all iterations        CRs=length(find(performance(:,7,:,i)==4)); %grand ttl #CRs over all iterations                %measures(i,1:5) filled in above (ca. line 538)        measures(i,6)=CDs/(CDs+MDs); % experienced pCD over iterations of playbacks        measures(i,7)=FAs/(FAs+CRs); % experienced pFA over iterations of playbacks                datatype.type='frequency'; %settings for EVALUATE                measures(i,8)=evaluate([CDs FAs MDs CRs],'precision',datatype); %as experienced over playbacks        measures(i,9)=evaluate([CDs FAs MDs CRs],'accuracy',datatype);        measures(i,10)=evaluate([CDs FAs MDs CRs],'dprime',datatype);        measures(i,11)=evaluate([CDs FAs MDs CRs],'bias',datatype);                            endend %for-loop of param settings.disp('MODELED VALUES')disp('    P[CD]     P[FA]     Slope   Treshold   HotSpot')measures(:,1:5)datatype.type='frequency'; %settings for EVALUATE        ac=evaluate([round(measures(:,1)*100).*alpha' round(measures(:,2)*100).*(1-alpha)' round((1-measures(:,1))*100).*alpha' round((1-measures(:,2))*100).*(1-alpha)'],'accuracy',datatype);b=evaluate([round(measures(:,1)*100).*alpha' round(measures(:,2)*100).*(1-alpha)' round((1-measures(:,1))*100).*alpha' round((1-measures(:,2))*100).*(1-alpha)'],'bias',datatype);d=evaluate([round(measures(:,1)*100).*alpha' round(measures(:,2)*100).*(1-alpha)' round((1-measures(:,1))*100).*alpha' round((1-measures(:,2))*100).*(1-alpha)'],'dprime',datatype);v=evaluate([round(measures(:,1)*100).*alpha' round(measures(:,2)*100).*(1-alpha)' round((1-measures(:,1))*100).*alpha' round((1-measures(:,2))*100).*(1-alpha)'],'raw_counts',datatype);disp('   Utility  Accuracy    bias    dprime          est. values: CD FA MD CR')[received_th_util' ac b d v]disp('EXPERIENCED VALUES (from playback iterations)')disp(' experP[CD] experP[FA] experPrec experAccur experDprime experBias')measures(:,6:end)%% For util of SxB spacedisp('RECEIVED SXB VARS (first=accurate)') %for upper half of misest-alphadisp(' modl_th_util ;   experDprime  ;  experBias')[received_th_util;measures(:,10)';measures(:,11)']% disp('RECEIVED SXB VARS (last=accurate)') %for lower half misest-alphadisp(' modl_th_util  ;  experDprime  ;  experBias')% [fliplr(received_th_util); fliplr(measures(:,10)'); fliplr(measures(:,11)'); fliplr(measures(:,11)')]%%writefiles(outputfilepath)end %fn MAINfunction fetch_playbacks %SET FOR SIGNAL 1 = S+.% playbacks= #experimental trials = number of signals to fetch in each sample loop.% iterations= #simuluations = number of times to loop though playback sequence, gets averaged for each trial.global performance samples directionglobal numsets roundby x_range hs_response_ara measuresglobal h j a m muSplus muSminus var1 var2 alpha iterations playbacks %params=arrays: 1st value = e-param, remaining=i-params%Two main matrixes:%SAMPLES = the playback signals for each iteration. Rows=playback signals, cols=1 accno, 2=signal source, 3=signal value, 3d=iteration%PERFORMANCE = the responses to the signals for each iteration for each param set (most of former mastersamples matrix, with added dim=numsets, and without sample info)pcols=7; %Number of data cols in performance matrix%         col7=outcome code: 1=cd,2=fa,3=md,4=cr; col6=hot cumu po, col5=hot pay, col4= hot resp prob, col3=thres cumu po, col2=thres payoff, Col1=sig accession#scols=3;  %Number of data cols in performance matrix%         col3=sampled x-value, col2=sig source, Col1=sig accession#performance=zeros(playbacks,pcols,iterations,numsets)*NaN; %array to hold counts of CDs, etc, and compute accuracy, etc for each series of playbackssamples=zeros(playbacks,scols,iterations)*NaN; %Initialize sample array.for iter_ct=1:iterations % iterations= #simuluations = number of times to loop though playback (=trial) sequence, gets averaged across same trial ##s.    %Get SAMPLE signals    unirand=rand(playbacks,1); %Get an array of Uniform rnd #'s btw 0-1. If >alpha, then a playback signal (=a trial) is from SIGNAL 2    sig2index=find(unirand>alpha(1)); %Assign (1-ALPHA)% of the rnds to come from Signal 2  (this for S+=sig1).    spacer=length(sig2index); %Last row of signal two samples. Used many times below...    samples(1:spacer,1,iter_ct)=sig2index; %Col1=index number of sample.    samples(1:spacer,2,iter_ct)=2; %Col2=signal source.    samples(1:spacer,3,iter_ct)=normrnd(muSminus(1),var2(1),spacer,1); %Poll for random numbers from Signal 2, put into col3.    sig1index=find(unirand<=alpha(1)); %Get the playbacks to come from SIGNAL 1: all samples from 0 to alpha (this for S+=sig1).    samples(spacer+1:end,1,iter_ct)=sig1index; %Col1=index number of sample.    samples(spacer+1:end,2,iter_ct)=1; %Col2=signal source.    samples(spacer+1:end,3,iter_ct)=normrnd(muSplus(1),var1(1),length(sig1index),1); %Poll for random numbers from Signal 1, put into col3.    hs_respprob=rand(playbacks,1); %Get uniform random numbers from 0-1. These will indicate predators response to signal.    for set_ct=1:numsets%get TH responses        performance(:,1,iter_ct,set_ct)=samples(:,1,iter_ct); %copy signal accession number to col 1 of performannce array.        %THRESHOLD RESPONSES - respond to e-param signals with i-param "threshold" value, accrue e-payoffs        % To make sig2=S+, reverse >/<'s re threshold assignments, swap a's h's etc re payoff assignments.        %Assign payoffs to signals. Could use SIGBE'S payoffsmod.m to bias payoff values "payoffsmod('h',rw,sig2index)"        th=measures(set_ct,4); %get threshold for current paramset        %How this works: "1:spacer"=sig2 (S-) signals. If respond to them (ie, sample value<=th)        %then you get an FA, payed at e-rate...etc.        %{             If mean S+<S- then S+ distn is to left of S-, and CDs are to left of threshold (as originally programmed)             But, if mean S+>S- then S+ distn is to right of S-, and CDs are to right of threshold.             Switching on threshold side corrects a problem in which CD,FA, etc in PERFORMANCE were getting loaded with             complementary values and sums of payoffs, counts of hits, etc. were then wrong.        %}        switch direction            case 'left'                [rw,cl]=find(samples(1:spacer,3,iter_ct)<=th); %Find FA samples (sig2 less than threshold for S+=sig1: eat to left of t)                performance(rw,2,iter_ct,set_ct)=a(1); %Compute sample's payoff, put into SAMPLE col4.                performance(rw,7,iter_ct,set_ct)=2; %set outcome code: 1=cd,2=fa,3=md,4=cr;                [rw,cl]=find(samples(1:spacer,3,iter_ct)>th); %Find CR samples.                performance(rw,2,iter_ct,set_ct)=j(1); %Compute sample's payoff, put into SAMPLE col4.                performance(rw,7,iter_ct,set_ct)=4; %set outcome code: 1=cd,2=fa,3=md,4=cr;                [rw,cl]=find(samples(spacer+1:end,3,iter_ct)<=th); %Find the samples which are CDs.                performance(rw+spacer,2,iter_ct,set_ct)=h(1); %Compute sample's payoff, put into SAMPLE col4.                performance(rw+spacer,7,iter_ct,set_ct)=1; %set outcome code: 1=cd,2=fa,3=md,4=cr;                [rw,cl]=find(samples(spacer+1:end,3,iter_ct)>th); %Find MD samples.                performance(rw+spacer,2,iter_ct,set_ct)=m(1); %Compute sample's payoff, put into SAMPLE col4.                performance(rw+spacer,7,iter_ct,set_ct)=3; %set outcome code: 1=cd,2=fa,3=md,4=cr;                performance(:,:,iter_ct,set_ct)=sortrows(performance(:,:,iter_ct,set_ct)); %Sort samples in order received for plotting & cumulative stats.                performance(:,3,iter_ct,set_ct)=cumsum(performance(:,2,iter_ct,set_ct));%Note: cum stats are dependent on accurate measure of central tendancy, ie Normal PDFs.            case 'right'                [rw,cl]=find(samples(1:spacer,3,iter_ct)>=th); %Find FA samples (sig2 less than threshold for S+=sig1: eat to left of t)                performance(rw,2,iter_ct,set_ct)=a(1); %Compute sample's payoff, put into SAMPLE col4.                performance(rw,7,iter_ct,set_ct)=2; %set outcome code: 1=cd,2=fa,3=md,4=cr;                [rw,cl]=find(samples(1:spacer,3,iter_ct)<th); %Find CR samples.                performance(rw,2,iter_ct,set_ct)=j(1); %Compute sample's payoff, put into SAMPLE col4.                performance(rw,7,iter_ct,set_ct)=4; %set outcome code: 1=cd,2=fa,3=md,4=cr;                [rw,cl]=find(samples(spacer+1:end,3,iter_ct)>=th); %Find the samples which are CDs.                performance(rw+spacer,2,iter_ct,set_ct)=h(1); %Compute sample's payoff, put into SAMPLE col4.                performance(rw+spacer,7,iter_ct,set_ct)=1; %set outcome code: 1=cd,2=fa,3=md,4=cr;                [rw,cl]=find(samples(spacer+1:end,3,iter_ct)<th); %Find MD samples.                performance(rw+spacer,2,iter_ct,set_ct)=m(1); %Compute sample's payoff, put into SAMPLE col4.                performance(rw+spacer,7,iter_ct,set_ct)=3; %set outcome code: 1=cd,2=fa,3=md,4=cr;                performance(:,:,iter_ct,set_ct)=sortrows(performance(:,:,iter_ct,set_ct)); %Sort samples in order received for plotting & cumulative stats.                performance(:,3,iter_ct,set_ct)=cumsum(performance(:,2,iter_ct,set_ct));%Note: cum stats are dependent on accurate measure of central tendancy, ie Normal PDFs.        end %switch    end %TH set_ct for each paramset    samples(:,:,iter_ct)=sortrows(samples(:,:,iter_ct),1); %Sort samples in order received for hs calcs.    for set_ct=1:numsets %get HS responses        %HOTSPOT RESPONSES - respond to e-param signals with i-param HS util envelope (="response" array), accrue e-payoffs        % To make sig2=S+, change 1's & 2's re "if samples(i,2)==1" source queries.        response=hs_response_ara(set_ct,:); %get hs response envolope for current paramset        performance(:,4,iter_ct,set_ct)=hs_respprob; %same for each paramset        for i=1:playbacks %assign payoffs for decision to each playback            xval=rounder(samples(i,3,iter_ct),roundby); %Round the signal value to nearest x_range chunk to find how this signal was percieved.            hitlist=find(xval==x_range); %Lookup response gradient probability corresponding to the signal's value.            if performance(i,4,iter_ct,set_ct)<=response(hitlist(1)) %If rnd draw is btw 0-response prob, predator attacks: either CD or FA.                if samples(i,2,iter_ct)==1 %from signal 1 = A CD                    performance(i,5,iter_ct,set_ct)=h(1);                    %[samples(i,2:3) response(hitlist(1)) samples(i,6:7)]% visually check assignments                else %A FA                    performance(i,5,iter_ct,set_ct)=a(1);                    %[samples(i,2:3) response(hitlist(1)) samples(i,6:7)]% visually check assignments                end            else %Predator doesn't attack: MD or CR                if samples(i,2,iter_ct)==1 %signal 1 = A MD                    performance(i,5,iter_ct,set_ct)=m(1);                    %[samples(i,2:3) response(hitlist(1)) samples(i,6:7)]% visually check assignments                else %A CR                    performance(i,5,iter_ct,set_ct)=j(1);                    %[samples(i,2:3) response(hitlist(1)) samples(i,6:7)]% visually check assignments                end            end        end %For hotspot response to playbacks.        performance(:,6,iter_ct,set_ct)=cumsum(performance(:,5,iter_ct,set_ct)); %Note: cum stats are dependent on accurate measure of central tendancy, ie Normal PDFs.    end %HS set_ct for each paramsetend % iter_ct for each iteration%{%Check distns, means, assignmentsperformancefigure; hold onplot(samples(find(samples(:,2,1)==2),3,1),'b.') %plot sig2 distn for first iterationplot(samples(find(samples(:,2,1)==1),3,1),'g.') %plot sig1 distn for first iterationdisp('mean sig2')%mean(samples((find(samples(:,2,1)==2),3,1),1)) %mean sig2disp('mean sig1')%mean(samples((find(samples(:,2,1)==1),3,1),1)) %mean sig2disp('    accno     source     sample   cummTh   cummHS   Outcome')[samples(:,:,1) performance(:,[3 7],1,1)] %print signals and outcomes%}end % fn FETCH_PLAYBACKS %%%%%%%%%%%%%%%%%%%function thr_index=implement_params(h,j,a,m,muSplus,muSminus,var1,var2,alpha)global x_range%genl globalsglobal pCD pFA S threshold response maxhotspotloc %globals reported back to MAINglobal hs_ara cl_ara fa_ara cd_ara Splus_distn Sminus_distn pfa2 yint hstloc minhotspotloc %add'l globals for use in figures    %CLASSIC CALCS = use normCDF. normcdf=integral from -INF to x:    %if muSplus(=S+) is less than muSminus(=S-) (attack to left of threshold) CD & FA =normcdf, MD & CR =1-normcdf    %if muSplus(=S+) is less than muSminus(=S-) (attack to right of threshold) CD & FA =1-normcdf, MD & CR =normcdf    if(muSplus<muSminus) %S+ to left of S- on increasing x-axis        cd_ara=normcdf(x_range,muSplus,var1);        fa_ara=normcdf(x_range,muSminus,var2);    else %S+ to right of S- on increasing x-axis        cd_ara=1-normcdf(x_range,muSplus,var1);        fa_ara=1-normcdf(x_range,muSminus,var2);    end    md_ara=1-cd_ara;    cr_ara=1-fa_ara;diff_cd=diff(cd_ara);diff_fa=diff(fa_ara);slope_ara=diff_cd./diff_fa; %Calc slopes of ROC at each point = [(y2-y1)/(x2-x1)].S=eval('((1-alpha)*(j-a))/(alpha*(h-m))'); %Slope of indifference line.classic_util='cd_ara*alpha*h+alpha*m*md_ara+(1-alpha)*a*fa_ara+(1-alpha)*j*cr_ara'; %Classic Utility.cl_ara=eval(classic_util); %Generate utilty curve%Find best match to S in slope_ara:s_ara=ones(1,length(slope_ara))*S; % make array of size, filled with S values_ara=slope_ara-s_ara; %subtract one from anothers_ara=s_ara.*s_ara; %square the differenceshitlist=find(s_ara==min(s_ara)); %the smallest sqare difference locates the closest match to S.hitslope=slope_ara(hitlist); %return array of matches to S (identical-value, closest match)thr_index=find(cl_ara==max(cl_ara)); %index into cl_ara of its max value.thr_index=thr_index(1); %in case multiple identical valuespCD=cd_ara(find(cl_ara==max(cl_ara)));pFA=fa_ara(find(cl_ara==max(cl_ara)));threshold=x_range(find(cl_ara==max(cl_ara))); %Get the threshold location%Some params settings will force extreme t's; result in multiple identical%extreme values. Just pick one.if (length(pCD)>1 || length(pFA)>1 || length(threshold)>1)    pCD=pCD(1);    pFA=pFA(1);    threshold=threshold(1); %some params will force multiple extreme t's (all equal, eg at max). Used by fetch_playbacks.    disp(strcat('Parameter set = ',num2str(i)))    disp('Multiple pCD, pFA or threshold estimates. Using first.')endif (S==0 || S>100)    disp('Extreme threshold location')end%Indifference Line using using new HitSlope and accurate pCD,pFAyint=pCD-(hitslope(1)*pFA); %y-interceptpfa2=((1-pCD)/hitslope(1))+pFA; %pFA value when pCD=1 = top of indifference line: based on S=[(y2-y1)/(x2-x1)]%HOTSPOT CALCS = use normPDFSplus_distn=normpdf(x_range,muSplus,var1);Sminus_distn=normpdf(x_range,muSminus,var2);hotspot_util='(Splus_distn*alpha*h+Sminus_distn*(1-alpha)*a)-(Splus_distn*alpha*m+Sminus_distn*(1-alpha)*j)'; %HotSpot utility fn.hs_ara=eval(hotspot_util); %Generate utilty curves%Get the max hotspot location on x-axis.maxhotspotloc=x_range(find(hs_ara==max(hs_ara)));minhotspotloc=x_range(find(hs_ara==min(hs_ara)));%Get the zero of hotspot location on x-axis. There's an easier way to%do this with calculus, but...if ~isempty(find(hs_ara<0)) %Eg, for extreme threshold locations    hszero_ara=hs_ara(find(hs_ara==max(hs_ara)):find(hs_ara==min(hs_ara))); %get portion of HS encompassing zero    hs2_ara=hszero_ara.*hszero_ara; %sqare values so can find point closest to zero    zero2=min(hs2_ara); %min value, sqaured    zero2loc=find(hs2_ara==zero2); %index to min sqaured value within partial array    hszero=hszero_ara(zero2loc); %unsquared value nearest zero within partial array; can be >1 value (=symmetric +/- 0)    if length(hszero)>1        hszero    end        try            hszeroloc=find(hs_ara==hszero(1)); %index within full array to "zero" value(s).            hstloc=x_range(hszeroloc); %x-range location of HS-derived threshold        catch exception            disp(' ')            disp('ERROR caught near line 208: Unable to do hszeroloc=find(hs_ara==hszero(1))')            disp('A non-critical error associated with muS+ > muS- (from inflexible coding)')            disp('that only effects determination of threshold via HS x-axis 0 location.')            disp('ML probably says: "index out of bounds because numel(hszero)=0."')            disp(' ')            exception.message        endelse    disp('Hotspot fn has no zero.')end%Transform hotspot in to response probability gradient via%normalization/linear scalingresponse=(hs_ara-min(hs_ara))/(max(hs_ara)-min(hs_ara)); %Linear scaling to [0,1]. Used by fetch_playbacks.end %implement paramsfunction writefiles(mypath) %Just writes data for the last param setglobal response hs_ara cl_ara x_range fa_ara cd_ara Splus_distn Sminus_distn iterationsglobal performance numsetscd (mypath)disp('comp_misest_out.txt column headings:')disp('hotspot_util x_range classic_util cd_ara fa_ara Splus_distn Sminus_distn Response_Probs')dataout=[transpose(hs_ara) transpose(x_range) transpose(cl_ara) transpose(cd_ara) transpose(fa_ara) transpose(Splus_distn) transpose(Sminus_distn) transpose(response)];save 'comp_misest_out.dat' dataout -ASCII -TABSif iterations>0 %save payoff output file disp('misest_payoffs.dat column headings:') disp('cummTh   cummHS') %mean cumulative threshold & HS payoff for each accession number over all iterations.dataout=[mean(performance(:,3,:,numsets),3) mean(performance(:,6,:,numsets),3)];save 'misest_payoffs.dat' dataout -ASCII -TABS   end    end %%%%%%%%%%%%% End WRITEFILES %%%%%%%%%%%%%%%%%%%function plotsignals(fighandle,c)%    FIGURE 1: Plot signal PDFs, threshold, hotspot util fn.%    PDF1 - blue (model: CR/FA), mean=0; PDF2 - red (mimics:CD/MD). Eat everything to right of t.global x_range  hs_ara cl_ara cd_ara fa_ara threshold response Splus_distn Sminus_distn hstloc minhotspotloc maxhotspotloccolors=['b' 'r' 'g' 'm' 'c' 'y' 'b' 'r' 'g' 'm' 'c' 'y'];figure(fighandle)%plot(x_range,cd_ara,'g') %CDF envelope of S+.%plot(x_range,fa_ara,'b') %CDF envelope of S-.plot(x_range,Splus_distn,'k','LineWidth',1.5) %Distn of S+.plot(x_range,Sminus_distn,'k','LineWidth',1.5) %Distn of S-.% plot(x_range,hs_ara,colors(c),'LineWidth',2) %hotspot util fn% plot([minhotspotloc minhotspotloc],[-.1 .1],'r') % min  of HotSpot fn% plot([maxhotspotloc maxhotspotloc],[-.1 .1],colors(c)) % max of HotSpot fn%plot([hstloc hstloc],[-.1 .1],'k') % threshold as zero of HotSpot fn%plot(x_range,response,'r') %normalized HS response probability gradient  plot(x_range,cl_ara,'k') %classic util fn  plot([threshold threshold],[-.025 .2],strcat(colors(c)),'LineWidth',2) % thresholdend %%%%%%%%%%%%% End  %%%%%%%%%%%%%%%%%%%function plotroc(fighandle,c)%    FIGURE 2: Plot ROC & Indifference Lineglobal cd_ara fa_ara pfa2 yintcolors=['b' 'r' 'g' 'm' 'c' 'y'];figure(fighandle)plot(fa_ara,cd_ara,'k')plot([0 pfa2],[yint 1],colors(c)) %Indif line.end %%%%%%%%%%%%% End  %%%%%%%%%%%%%%%%%%%function plotpayoffs(fighandle,c)global performance%    FIGURE 3: Plot accrued payoffsfigure(fighandle)colors=['b' 'r' 'g' 'm' 'c' 'y' 'b' 'r' 'g' 'm' 'c' 'y'];plot(mean(performance(:,3,:,c),3),strcat(colors(c)),'LineWidth',2)%Plot mean cumulative threshold payoff for each accession number over all iterations.% colors=jet(10);% plot(mean(performance(:,3,:,c),3),colors(c,:),'LineWidth',2)%Plot mean cumulative threshold payoff for each accession number over all iterations.%plot(mean(performance(:,6,:,c),3),colors(c))%Plot mean cumulative hotspot payoff for each accession number over all iterations.%NO LONGER USED: for i=[1:playbacks]%	plot([mastersamples(i,1,1) mastersamples(i,1,1)],[mean(mastersamples(i,5,:))+std(mastersamples(i,5,:)) mean(mastersamples(i,5,:))-std(mastersamples(i,5,:))],'-k')%   plot +/- 1 SD error bars overlayed on mean cumulative payoff%endend % fn %%%%%%%%%%%%%%%%%%%function plotperformance(fighandle,c) %not working: needs access to CDs, etc, at each iterationglobal performancecolors=['b' 'r' 'g' 'm' 'c' 'y'];figure(fighandle)plot(performance(:,5),strcat(colors(c),'--'))%Plot mean cumulative performance measures for each accession number over all iterations.plot(performance(:,6),strcat(colors(c),'-.'))%Plot mean cumulative performance measures for each accession number over all iterations.plot(performance(:,7),strcat(colors(c),':'))%Plot mean cumulative performance measures for each accession number over all iterations.plot(performance(:,8),colors(c))%Plot mean cumulative performance measures for each accession number over all iterations.end % fn %%%%%%%%%%%%%%%%%%%