function results=compare_params2(scenarios,plots,exptName,writeflag)%SAtb fn: compare_params2% Compare utilities, ROC, etc of multiple SDT parameter manipulations% - writes 2 datafiless to ML's current directory.%% Usage: compare_params2(scenario)% Where scenario is a set of signal parameters defined elsewhere.%% Requires ML's Statistics Toolbox because uses NORMCDF fn. Will return an% error about normcdf and doubles if tb not licensed,installed.%% edit compare_params2   %triple-click me and press return to edit.%%% Features:%   Implementation of classic SDT util function using NORMCDF (whereas older SigBE program uses Wieble fn)%   Implementation of hotspot util using NORMPDF%    PDF1 - green; S+ (target) CD/MD%    PDF2 - blue; S- (foil) FA/CR%% Spencer Lynn <spencer.lynn@gmail.com>% 3/16/10, version 2/18/11.1    Based on compare_params.m, siggy.m%% Change Log:% 02/18/11 - For HS response probabiity grandient, replaced linear scaling from 0-1 with -/+ relative to abs largest utility value.%          - Added struct for returning results (eg, response gradients)% 5/26/11  - Changed datatype.type =>'rate' to get more accurate model est. d', etc from evaluate.m% 1/31/11  - Commented out measures display (lines 84, 240). It's replaced by fn output.% 6/25/12  - Created write-flag input parameter to control output file creation.% 10/21/12 - discovered that accuracy and precision not calculated correctly by fn evaluate.m if datatype=rate. Replaced with NaN.% 11/9/12 - Fixed above for 'rate' in evaluate (not for fraction or precision)% 12/18/12 - Need to edit this version? Check compare_params3 - forked to make classic util indpendent of payoff assumptions (re CD>FA, etc).% 05/12/14 - Added plotting option for z-transform ROC (not added to other versions of compare_params.% 09/27/14 - Edited use of writeLine to prevent data overwriting by headers.% 05/22/16 - added catch ploterror and if..zroc to try/plots section, trouble shooting pmetric plotting. Wierd that zroc not present, as there's code to plot it below.% 07/30/16 - try/catch plot not working. Many expt_model scripts missing plots.pmetric.on = 0;plots.zroc.on=0 lines, causing this.                  % 20160923 - Adding PDFs, CDFs to results output struct.%TO DO:% - Many expt_model scripts missing plots.pmetric.on = 0;plots.zroc.on=0 lines, causing crashes. %-some out of range errors when x_range not big enough.% - can't handle target,foil SDs=0%%%%%%%%%%%%%%global h j a m muSplus muSminus var1 var2 alphaglobal response measures x_range threshold hs_ara cl_ara fa_ara cd_ara Splus_distn Sminus_distn pfa2 yint hstloc minhotspotloc maxhotspotloch=scenarios.h;j=scenarios.j;a=scenarios.a;m=scenarios.m;muSplus=scenarios.muTarget;muSminus=scenarios.muFoil;var1=scenarios.varTarget;var2=scenarios.varFoil;alpha=scenarios.baserate;x_range=scenarios.x_range;%init plot windows% try %if PLOTS not passed on fn call, not a problem    if sum([plots.Splus_distn.on,...            plots.Sminus_distn.on,...            plots.cd_ara.on,...            plots.fa_ara.on,...            plots.cl_ara.on,...            plots.threshold.on,...            plots.hstloc.on,...            plots.hs_ara.on,...            plots.HS_linear_scale.on,...            plots.minhotspotloc.on,...            plots.maxhotspotloc.on])>=1        fighandles.distributions=figure;        hold on; zoom on    end    if sum([plots.roc.on,...            plots.indiffence_line.on])        fighandles.roc=figure;        hold on; zoom on    end    if sum([plots.zroc.on])        fighandles.zroc=figure;        hold on; zoom on    end        if sum([plots.pmetric.on])        fighandles.pmetric=figure;        hold on; zoom on    end% catch ploterror%    if plots~=0%         ploterror%     end% end %try%init measurements data matrixmeasures=ones(length(muSplus),13)*NaN; %cols=P[CD] P[FA] Slope Tloc HSloc prec accur dpr bias ...% Creat output struct: eg, One row for each scenario, One column for each signal value.results.hs_rgradient=ones(length(muSplus),numel(x_range))*NaN;for i=1:length(scenarios.names) %loop for each set of param values%     scenarios.names(i) %print current scenario        %settings for EVALUATE    datatype.type='rate';%     datatype.type='fraction';    datatype.baserate=alpha(i);    datatype.numTrials=20000; %Adjust this higher if get non-monotonic hiccoughs in performance measures (d', betag)                    %CLASSIC CALCS = use normCDF. normcdf=integral from -INF to x:    %if muSplus(=S+) is less than muSminus(=S-) (attack to left of threshold) CD & FA =normcdf, MD & CR =1-normcdf    %if muSplus(=S+) is more than muSminus(=S-) (attack to right of threshold) CD & FA =1-normcdf, MD & CR =normcdf%     - 20160923 I think I phrased it this way when YES was id of an aposeme?    if(muSplus(i)<muSminus(i)) %S+ to left of S- on increasing x-axis        cd_ara=normcdf(x_range,muSplus(i),var1(i));        fa_ara=normcdf(x_range,muSminus(i),var2(i));    else %S+ to right of S- on increasing x-axis        cd_ara=1-normcdf(x_range,muSplus(i),var1(i));        fa_ara=1-normcdf(x_range,muSminus(i),var2(i));    end        md_ara=1-cd_ara;    cr_ara=1-fa_ara;        % extra bits for sxb util space    % size(evaluate([cd_ara' fa_ara' md_ara' cr_ara'],'dprime',datatype))    % size(cl_ara)    % [evaluate([cd_ara' fa_ara' md_ara' cr_ara'],'dprime',datatype) evaluate([cd_ara' fa_ara' md_ara' cr_ara'],'c',datatype) cl_ara']        %Calc slopes of ROC at each point = [(y2-y1)/(x2-x1)].    diff_cd=diff(cd_ara);    diff_fa=diff(fa_ara);    slope_ara=diff_cd./diff_fa;        S=eval('((1-alpha(i))*(j(i)-a(i)))/(alpha(i)*(h(i)-m(i)))'); %Slope of indifference line.    classic_util='cd_ara*alpha(i)*h(i)+alpha(i)*m(i)*md_ara+(1-alpha(i))*a(i)*fa_ara+(1-alpha(i))*j(i)*cr_ara'; %Classic Utility.    cl_ara=eval(classic_util); %Generate utilty curve        results.targetCDF=cd_ara;    results.foilCDF=fa_ara;    results.utilfn=cl_ara;        %New hitlist 3/21/08:    s_ara=ones(1,length(slope_ara))*S; % make array of size, filled with S value    s_ara=slope_ara-s_ara; %subtract one from another    s_ara=s_ara.*s_ara; %square the differences    hitlist=find(s_ara==min(s_ara)); %the smallest sqare difference locates the closest match to S.    hitslope=slope_ara(hitlist); %return array of matches to S (identical-value, closest match)        %Used to use old hitlist to get these, but was incorrect. Now use CDF.    pCD=cd_ara(find(cl_ara==max(cl_ara)));    pFA=fa_ara(find(cl_ara==max(cl_ara)));    threshold=x_range(find(cl_ara==max(cl_ara))); %Get the threshold location        %Some params settings will force extreme t's; result in multiple identical extreme values. Just pick one.    if (length(pCD)>1 || length(pFA)>1 || length(threshold)>1)        pCD=pCD(1);        pFA=pFA(1);        threshold=threshold(1); %some params will force multiple extreme t's (all equal, eg at max)        disp('Multiple pCD, pFA or threshold estimates. Using first. (In compare_params2.m)')    end    if (S==0 || S>100)        disp('Extreme threshold location, in compare_params2.m')    end        %Indifference Line using using new HitSlope and accurate pCD,pFA    yint=pCD-(hitslope(1)*pFA); %y-intercept, calc'd independent of indifference line eq's y-intercept (but uses only its slope).        % %Double-check that the indifference line eq.'s y-int is correct, as looks odd with (alpha)(j-a) rather than (1-alpha)(j-a).    % % indiff_line='((((1-alpha(i)).*(j(i)-a(i)))./(alpha(i).*(h(i)-m(i)))).*fa_ara)+((alpha(i).*(j(i)-m(i))-j(i)+u)./(alpha(i).*(h(i)-m(i))))'; %Corrected Wiley's typo.    % % indiff_yint_eq='((alpha(i).*(j(i)-m(i))-j(i)+u)./(alpha(i).*(h(i)-m(i))))'; %Corrected Wiley's typo.    % % WILEY_indiff_yint_eq='alpha(i).*(j(i)-m(i))-j(i)+u'; %UNcorrected Wiley's typo (missing denomenator).    % % u=max(cl_ara);    % % [yint eval(indiff_yint_eq)]        pfa2=((1-pCD)/hitslope(1))+pFA; %pFA value when pCD=1 = top of indifference line: based on S=[(y2-y1)/(x2-x1)]        %HOTSPOT CALCS = use normPDF    Splus_distn=normpdf(x_range,muSplus(i),var1(i));    Sminus_distn=normpdf(x_range,muSminus(i),var2(i));    hotspot_util='(Splus_distn*alpha(i)*h(i)+Sminus_distn*(1-alpha(i))*a(i))-(Splus_distn*alpha(i)*m(i)+Sminus_distn*(1-alpha(i))*j(i))'; %HotSpot utility fn.    hs_ara=eval(hotspot_util); %Generate utilty curves        results.targetPDF=Splus_distn;    results.foilPDF=Sminus_distn;        %Get the max hotspot location on x-axis.    maxhotspotloc=x_range(find(hs_ara==max(hs_ara)));    minhotspotloc=x_range(find(hs_ara==min(hs_ara)));        pMD=1-pCD;    pCR=1-pFA;        precision=evaluate([pCD pFA pMD pCR],'precision',datatype); %eval doesn't do this for datatype=rate, gets xformed to freq.    accuracy=evaluate([pCD pFA pMD pCR],'accuracy',datatype);  %eval doesn't do this for datatype=rate, gets xformed to freq.    dprime=evaluate([pCD pFA pMD pCR],'dprime',datatype);    bias=evaluate([pCD pFA pMD pCR],'bias',datatype);    betag=evaluate([pCD pFA pMD pCR],'betag',datatype);        %Get the zero of hotspot location on x-axis. There's an easier way to do this with calculus, but...    if ~isempty(find(hs_ara<0)) %Eg, for extreme threshold locations HS doesn't cross zero..."has no zero"        [mx maxi]=max(hs_ara);        [mn mini]=min(hs_ara);        if maxi>mini            hszero_ara=hs_ara(mini:maxi); %get portion of HS encompassing zero        else            hszero_ara=hs_ara(maxi:mini); %get portion of HS encompassing zero        end        hs2_ara=hszero_ara.*hszero_ara; %sqare values so can find point closest to zero        zero2=min(hs2_ara); %min value, sqaured        zero2loc=find(hs2_ara==zero2); %index to min sqaured value within partial array        hszero=hszero_ara(zero2loc); %unsquared value nearest zero within partial array; can be >1 value (=symmetric +/- 0)        if length(hszero)>1            hszero        end        hszeroloc=find(hs_ara==hszero(1)); %index within full array to "zero" value(s).        hstloc=x_range(hszeroloc); %x-range location of HS-derived threshold    else        disp('Hotspot fn has no zero. Cannot determine threshold location, in compare_params2.m.')    end            %% Transform hotspot util fn into response gradient    %...such that P["target"]is >0, P["foil"] is <0 :    %-Deterimin maxPOS minNEG by which to scale preserving relative p-target vs p-foil probabilities.    %-The largest (abs val) util (whether to target or foil) becomes the P[response]=1 limit on the scale.    %-The rest of the utility values are scaled relative to that.    maxHS=max(hs_ara);    minHS=min(hs_ara);    if abs(maxHS)>=abs(minHS)        new_max=maxHS/maxHS;        new_min=minHS/maxHS;    else        new_min=(minHS/minHS);        if minHS<0;new_min=new_min*-1;end %make negative if needed.        new_max=abs(maxHS/minHS); %should be positive    end%if    response=normalizer(hs_ara,new_min,new_max); %Linear Scaling    results.hs_rgradient(i,:)=response; %Make available for output.        %% Log results    measures(i,:)=[pCD pFA S threshold maxhotspotloc precision accuracy dprime bias max(cl_ara) max(hs_ara) betag minhotspotloc];        %% For current scenario: Write curve data points for utility fn, signals, etc    if writeflag==1        fdata.fname=strcat(exptName,'_',scenarios.names{i},'.dat');        fdata.formatStr='x_range \t Splus_distn \t Sminus_distn \t cd_ara \t fa_ara \t Response_Probs \t hotspot_util \t classic_util \n'; %print headers via the format string so escapes get inserted properly        disp(strcat([fdata.fname, ' column headers are: ',fdata.formatStr]));        spaces=findstr(' ',fdata.formatStr); %find spaces        fdata.formatStr(spaces)=[]; %remove spaces from human-readable version        fdata.dataout=[];        fdata=writeLine(fdata,{'open'}); %removed 'write' call as it was over-writing data.        fdata.dataout=[transpose(x_range) transpose(Splus_distn) transpose(Sminus_distn) transpose(cd_ara) transpose(fa_ara) transpose(response) transpose(hs_ara) transpose(cl_ara)];        fdata=writeLine(fdata,{'append' 'close'});    end    %%    try        if isstruct(fighandles)            update_plots(plots,fighandles,scenarios,i) %pass scenarios struct and index to current scenario        end    end    end %for-loop of param settingsresults.measures=measures;results.key={'P[CD]' 'P[FA]' 'Slope' 'Threshold' 'HotSpot' 'Precision' 'Accuracy' 'dPrime' 'Bias' 'maxCl Util' 'maxHS Util' 'beta' 'minHSloc'};%% For all scenarios: Write summary measuresif writeflag==1    fdata.fname=strcat(exptName,'_measures.dat');    fdata.formatStr='P[CD] \t P[FA] \t Slope \t Threshold \t HotSpot \t Precision \t Accuracy \t dPrime \t Bias \t maxCl_Util \t maxHS_Util \t beta \t minHSloc \n';    disp(strcat([fdata.fname, ' column headers are: ',fdata.formatStr]));    spaces=findstr(' ',fdata.formatStr); %find spaces    fdata.formatStr(spaces)=[]; %remove spaces from human-readable version    fdata.dataout=[]; %headers written via format string, no data    fdata=writeLine(fdata,{'open'}); %removed 'write' call as it was overwriting data.    fdata.dataout=[measures(:,1) measures(:,2) measures(:,3) measures(:,4) measures(:,5) measures(:,6) measures(:,7) measures(:,8) measures(:,9) measures(:,10) measures(:,11) measures(:,12) measures(:,13)];    fdata.formatStr='%i\t %i\t %i\t %i\t %i\t %i\t %i\t %i\t %i\t %i\t %i\t %i\n';    fdata=writeLine(fdata,{'append' 'close'});end%% plot series of measures over variation in a parameter%plot(measures(:,4),measures(:,6),'go',measures(:,4),measures(:,7),'ro') %precision, accuracy at each thresholdend %%%%%%%%%%%%% End MAIN %%%%%%%%%%%%%%%%%%%function fdata=writeLine(fdata,cmdList)%Write a single line of data to a file%fdata = a structure such that%     .fname = the file to create%     .fptr = assigned here, by open cmd%     .formatStr = fprintf C format string%     .dataout = the data to write (single line of text or matrix of numbers)%%cmdList = {'open'} %list of commands to run in sequence on parts of fdata.%%%%for i=1:length(cmdList)    switch cmdList{i}        case 'append' %append numeric matix to existing file            dlmwrite(fdata.fname,fdata.dataout,'-append','delimiter','\t'); %append matrix to text file        case 'open'            fdata.fptr = fopen(fdata.fname,'wt');        case 'write'            fprintf(fdata.fptr,fdata.formatStr,fdata.dataout); %Write single row of data        case 'close'            fclose(fdata.fptr);    end %switch commandsend %for each command in passed listend %fnfunction update_plots(plots,fighandles,scenarios,s)global response x_range threshold hs_ara cl_ara cd_ara fa_ara Splus_distn Sminus_distn hstloc minhotspotloc maxhotspotloc pfa2 yintfigures=fieldnames(fighandles); %list of figure types, set above as field namesfor i=1:length(figures)    figure(fighandles.(char(figures(i)))) %activate specified figure by it's handle number, stored in it's named field    switch char(figures(i))        case 'distributions'            if plots.Splus_distn.on;plot(x_range,Splus_distn,plots.Splus_distn.color,'LineWidth',plots.Splus_distn.linewidth);end%Distn of S+.            if plots.Sminus_distn.on;plot(x_range,Sminus_distn,plots.Sminus_distn.color,'LineWidth',plots.Sminus_distn.linewidth);end%Distn of S-.            if plots.cd_ara.on;plot(x_range,cd_ara,plots.cd_ara.color);end%CDF envelope of S+.            if plots.fa_ara.on;plot(x_range,fa_ara,plots.fa_ara.color);end%CDF envelope of S-.            if plots.cl_ara.on;plot(x_range,cl_ara,plots.cl_ara.color);end%classic util fn            if plots.threshold.on;plot([threshold threshold],[plots.threshold.min plots.threshold.max],plots.threshold.color,'LineWidth',plots.threshold.linewidth);end% threshold            try %hstloc is often zero if muTarget>muFoil due to inflexible coding on my part.                if plots.hstloc.on; plot([hstloc hstloc],[plots.threshold.min plots.threshold.max],plots.threshold.color,'LineWidth',plots.threshold.linewidth);end% threshold as zero of HotSpot fn            end            if plots.hs_ara.on;plot(x_range,hs_ara,plots.hs_ara.color);end%hotspot util fn            if plots.HS_linear_scale.on;plot(x_range,response,plots.HS_linear_scale.color);end%HS response probability gradient (lin scaled HS fn)            if plots.minhotspotloc.on;plot([minhotspotloc minhotspotloc],[plots.minhotspotloc.min plots.minhotspotloc.max],plots.minhotspotloc.color);end% min  of HotSpot fn            if plots.maxhotspotloc.on;plot([maxhotspotloc maxhotspotloc],[plots.maxhotspotloc.min plots.maxhotspotloc.max],plots.maxhotspotloc.color) ;end% max of HotSpot fn                    case 'roc'            if plots.roc.on;plot(fa_ara,cd_ara,'m');end            if plots.indiffence_line.on;plot([0 pfa2],[yint 1],'k');end            %output datapts            %[fa_ara' cd_ara']            %[[0 yint];[pfa2 1]]                    case 'zroc'            if plots.zroc.on;                 plot(norminv(fa_ara),norminv(cd_ara),'m') %z-transform ROC. norminv: %0,1 => -/+inf, won't get plotted.            %output datapts            %[norminv(fa_ara)' norminv(cd_ara)']            end    end %switch each figure typeend %for each figure%edit 'unused eqs.m' %to see more plots ideas.end %fn