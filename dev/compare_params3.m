function results=compare_params3(scenarios,plots,exptName,writeflag)%SAtb fn: compare_params3% Compare utilities, ROC, etc of multiple SDT parameter manipulations% - writes 2 datafiless to ML's current directory.%% Usage: compare_params3(scenario,...)% Where scenario is a set of signal parameters defined elsewhere.%% Requires ML's Statistics Toolbox because uses NORMCDF fn. Will return an% error about normcdf and doubles if tb not licensed,installed.%% edit compare_params3   %triple-click me and press return to edit.%%% Features:%   Implementation of classic SDT util function using NORMCDF (whereas older SigBE program uses Wieble fn)%   Implementation of hotspot util using NORMPDF%    PDF1 - green; S+ (target) CD/MD%    PDF2 - blue; S- (foil) FA/CR%% Spencer Lynn <spencer.lynn@gmail.com>% 3/16/10, version 2/18/11.1    Based on compare_params.m, siggy.m%% Change Log:% 02/18/11 - For HS response probabiity grandient, replaced linear scaling from 0-1 with -/+ relative to abs largest utility value.%          - Added struct for returning results (eg, response gradients)% 5/26/11  - Changed datatype.type =>'rate' to get more accurate model est. d', etc from evaluate.m% 1/31/11  - Commented out measures display (lines 84, 240). It's replaced by fn output.% 6/25/12  - Created write-flag input parameter to control output file creation.% 10/21/12 - discovered that accuracy and precision not calculated correctly by fn evaluate.m if datatype=rate. Replaced with NaN.% 11/9/12  - Fixed above for 'rate' in evaluate (not for fraction or precision)% % 12/18/12 - forked from compare_params2 to make classic util indpendent of payoff assumptions (re CD>FA, etc).%          - this involved commenting out a bunch of HS util code, and outputing different results.%          - But, writeLine seems to fail (overwrite existing data?) for really small values%          - Near line 260, prints to screen the CD, FA, etc, cummulative distribution values (eg for use in modeling in Excel, see JDM dev)% 8/19/13  - Appears to handle target, foil SD=0 just fine (but for writeLine output). See examples in JDM ms dev.% 09/27/14 - Edited use of writeLine to prevent data overwriting by headers.% %TO DO:% ?-some out of range errors when x_range not big enough.%%%%%%%%%%%%%%global h j a m muSplus muSminus var1 var2 alphaglobal response measures x_range threshold hs_ara cl_ara fa_ara cd_ara Splus_distn Sminus_distn pfa2 yint hstloc minhotspotloc maxhotspotloch=scenarios.h;j=scenarios.j;a=scenarios.a;m=scenarios.m;muSplus=scenarios.muTarget;muSminus=scenarios.muFoil;var1=scenarios.varTarget;var2=scenarios.varFoil;alpha=scenarios.baserate;x_range=scenarios.x_range;%init plot windowstry %if PLOTS not passed on fn call, not a problem    if sum([plots.Splus_distn.on,...            plots.Sminus_distn.on,...            plots.cd_ara.on,...            plots.fa_ara.on,...            plots.cl_ara.on,...            plots.threshold.on,...            plots.hstloc.on,...            plots.hs_ara.on,...            plots.HS_linear_scale.on,...            plots.minhotspotloc.on,...            plots.maxhotspotloc.on])>=1        fighandles.distributions=figure;        hold on; zoom on    end    if sum([plots.roc.on,...            plots.indiffence_line.on])        fighandles.roc=figure;        hold on; zoom on    end    if sum([plots.pmetric.on])        fighandles.pmetric=figure;        hold on; zoom on    endend %try%init measurements data matrixmeasures=ones(length(muSplus),8)*NaN; %cols=P[CD] P[FA] Slope Tloc HSloc prec accur dpr bias ...% Creat output struct: eg, One row for each scenario, One column for each signal value.results.hs_rgradient=ones(length(muSplus),numel(x_range))*NaN;for i=1:length(scenarios.names) %loop for each set of param values%     scenarios.names(i) %print current scenario        %settings for EVALUATE    datatype.type='rate';%     datatype.type='fraction';    datatype.baserate=alpha(i);    datatype.numTrials=20000; %Adjust this higher if get non-monotonic hiccoughs in performance measures (d', betag)                    %CLASSIC CALCS = use normCDF. normcdf=integral from -INF to x:    %if muSplus(=S+) is less than muSminus(=S-) (attack to left of threshold) CD & FA =normcdf, MD & CR =1-normcdf    %if muSplus(=S+) is more than muSminus(=S-) (attack to right of threshold) CD & FA =1-normcdf, MD & CR =normcdf        if(muSplus(i)<muSminus(i)) %S+ to left of S- on increasing x-axis        cd_ara=normcdf(x_range,muSplus(i),var1(i));        fa_ara=normcdf(x_range,muSminus(i),var2(i));    else %S+ to right of S- on increasing x-axis        cd_ara=1-normcdf(x_range,muSplus(i),var1(i));        fa_ara=1-normcdf(x_range,muSminus(i),var2(i));    end    md_ara=1-cd_ara;    cr_ara=1-fa_ara;        % extra bits for sxb util space    % size(evaluate([cd_ara' fa_ara' md_ara' cr_ara'],'dprime',datatype))    % size(cl_ara)    % [evaluate([cd_ara' fa_ara' md_ara' cr_ara'],'dprime',datatype) evaluate([cd_ara' fa_ara' md_ara' cr_ara'],'c',datatype) cl_ara']        %Calc slopes of ROC at each point = [(y2-y1)/(x2-x1)].%     diff_cd=diff(cd_ara);%     diff_fa=diff(fa_ara);%     slope_ara=diff_cd./diff_fa;    %     S=eval('((1-alpha(i))*(j(i)-a(i)))/(alpha(i)*(h(i)-m(i)))'); %Slope of indifference line.    classic_util='cd_ara*alpha(i)*h(i)+alpha(i)*m(i)*md_ara+(1-alpha(i))*a(i)*fa_ara+(1-alpha(i))*j(i)*cr_ara'; %Classic Utility.    cl_ara=eval(classic_util); %Generate utilty curve%     %     %New hitlist 3/21/08:%     s_ara=ones(1,length(slope_ara))*S; % make array of size, filled with S value%     s_ara=slope_ara-s_ara; %subtract one from another%     s_ara=s_ara.*s_ara; %square the differences%     hitlist=find(s_ara==min(s_ara)); %the smallest sqare difference locates the closest match to S.%     hitslope=slope_ara(hitlist); %return array of matches to S (identical-value, closest match)%     %     %Used to use old hitlist to get these, but was incorrect. Now use CDF.    pCD=cd_ara(find(cl_ara==max(cl_ara)));    pFA=fa_ara(find(cl_ara==max(cl_ara)));    threshold=x_range(find(cl_ara==max(cl_ara))); %Get the threshold location%     %     %Some params settings will force extreme t's; result in multiple identical extreme values. Just pick one.    if (length(pCD)>1 || length(pFA)>1 || length(threshold)>1)        pCD=pCD(1);        pFA=pFA(1);        threshold=threshold(1); %some params will force multiple extreme t's (all equal, eg at max)        disp('Multiple pCD, pFA or threshold estimates. Using first. (In compare_params3.m)')    end%     if (S==0 || S>100)%         disp('Extreme threshold location, in compare_params2.m')%     end%     %     %Indifference Line using using new HitSlope and accurate pCD,pFA%     yint=pCD-(hitslope(1)*pFA); %y-intercept%     pfa2=((1-pCD)/hitslope(1))+pFA; %pFA value when pCD=1 = top of indifference line: based on S=[(y2-y1)/(x2-x1)]%     %     %HOTSPOT CALCS = use normPDF    Splus_distn=normpdf(x_range,muSplus(i),var1(i));    Sminus_distn=normpdf(x_range,muSminus(i),var2(i));%     hotspot_util='(Splus_distn*alpha(i)*h(i)+Sminus_distn*(1-alpha(i))*a(i))-(Splus_distn*alpha(i)*m(i)+Sminus_distn*(1-alpha(i))*j(i))'; %HotSpot utility fn.%     hs_ara=eval(hotspot_util); %Generate utilty curves%     %     %Get the max hotspot location on x-axis.%     maxhotspotloc=x_range(find(hs_ara==max(hs_ara)));%     minhotspotloc=x_range(find(hs_ara==min(hs_ara)));%         pMD=1-pCD;    pCR=1-pFA;        precision=evaluate([pCD pFA pMD pCR],'precision',datatype); %eval doesn't do this for datatype=rate.    accuracy=evaluate([pCD pFA pMD pCR],'accuracy',datatype);  %eval doesn't do this for datatype=rate.    dprime=evaluate([pCD pFA pMD pCR],'dprime',datatype);    bias=evaluate([pCD pFA pMD pCR],'bias',datatype);    betag=evaluate([pCD pFA pMD pCR],'betag',datatype);    %     %Get the zero of hotspot location on x-axis. There's an easier way to do this with calculus, but...%     if ~isempty(find(hs_ara<0)) %Eg, for extreme threshold locations HS doesn't cross zero..."has no zero"%         [mx maxi]=max(hs_ara);%         [mn mini]=min(hs_ara);%         if maxi>mini%             hszero_ara=hs_ara(mini:maxi); %get portion of HS encompassing zero%         else%             hszero_ara=hs_ara(maxi:mini); %get portion of HS encompassing zero%         end%         hs2_ara=hszero_ara.*hszero_ara; %sqare values so can find point closest to zero%         zero2=min(hs2_ara); %min value, sqaured%         zero2loc=find(hs2_ara==zero2); %index to min sqaured value within partial array%         hszero=hszero_ara(zero2loc); %unsquared value nearest zero within partial array; can be >1 value (=symmetric +/- 0)%         if length(hszero)>1%             hszero%         end%         hszeroloc=find(hs_ara==hszero(1)); %index within full array to "zero" value(s).%         hstloc=x_range(hszeroloc); %x-range location of HS-derived threshold%     else%         disp('Hotspot fn has no zero. Cannot determine threshold location, in compare_params2.m.')%     end        %     %% Transform hotspot util fn into response gradient%     %...such that P["target"]is >0, P["foil"] is <0 :%     %-Deterimin maxPOS minNEG by which to scale preserving relative p-target vs p-foil probabilities.%     %-The largest (abs val) util (whether to target or foil) becomes the P[response]=1 limit on the scale.%     %-The rest of the utility values are scaled relative to that.%     maxHS=max(hs_ara);%     minHS=min(hs_ara);%     if abs(maxHS)>=abs(minHS)%         new_max=maxHS/maxHS;%         new_min=minHS/maxHS;%     else%         new_min=(minHS/minHS);%         if minHS<0;new_min=new_min*-1;end %make negative if needed.%         new_max=abs(maxHS/minHS); %should be positive%     end%if%     response=normalizer(hs_ara,new_min,new_max); %Linear Scaling%     results.hs_rgradient(i,:)=response; %Make available for output.        %% Log results%     measures(i,:)=[pCD pFA S threshold maxhotspotloc precision accuracy dprime bias max(cl_ara) max(hs_ara) betag minhotspotloc];      measures(i,:)=[pCD pFA threshold accuracy dprime bias max(cl_ara) betag];          %% For current scenario: Write curve data points for utility fn, signals, etc    if writeflag==1        fdata.fname=strcat(exptName,'_',scenarios.names{i},'.dat');        fdata.formatStr='x_range \t Splus_distn \t Sminus_distn \t cd_ara \t fa_ara \t classic_util \n'; %print headers via the format string so escapes get inserted properly        disp(strcat([fdata.fname, ' column headers are: ',fdata.formatStr]));        spaces=findstr(' ',fdata.formatStr); %find spaces        fdata.formatStr(spaces)=[]; %remove spaces from human-readable version        fdata.dataout=[];        fdata=writeLine(fdata,{'open'});        fdata.dataout=[transpose(x_range) transpose(Splus_distn) transpose(Sminus_distn) transpose(cd_ara) transpose(fa_ara) transpose(cl_ara)];        fdata=writeLine(fdata,{'append'});        fdata.dataout=[];        fdata=writeLine(fdata,{'close'});    end       %%    try        if isstruct(fighandles)            update_plots(plots,fighandles,scenarios,i) %pass scenarios struct and index to current scenario        end    end    end %for-loop of param settingsresults.measures=measures;results.key={'P[CD]' 'P[FA]' 'Threshold' 'Accuracy' 'dPrime' 'Bias' 'maxCl Util' 'beta'};%% For all scenarios: Write summary measuresif writeflag==1    fdata.fname=strcat(exptName,'_measures.dat');    fdata.formatStr='P[CD] \t P[FA] \t Threshold \t Accuracy \t dPrime \t Bias \t maxCl_Util \t beta \n';    disp(strcat([fdata.fname, ' column headers are: ',fdata.formatStr]));    spaces=findstr(' ',fdata.formatStr); %find spaces    fdata.formatStr(spaces)=[]; %remove spaces from human-readable version    fdata.dataout=[]; %headers written via format string, no data    fdata=writeLine(fdata,{'open'}); %removed  'write' as it's overwriting following data somehow.    fdata.dataout=[measures(:,1) measures(:,2) measures(:,3) measures(:,4) measures(:,5) measures(:,6) measures(:,7) measures(:,8)];    fdata.formatStr='%i\t %i\t %i\t %i\t %i\t %i\t %i\t %i\n';    fdata=writeLine(fdata,{'append' 'close'});end%% plot series of measures over variation in a parameter%plot(measures(:,4),measures(:,6),'go',measures(:,4),measures(:,7),'ro') %precision, accuracy at each threshold%Print to screendisp('normCDF for CD, MD, FA, CR  ...for last scenario.')[cd_ara' md_ara' fa_ara' cr_ara']end %%%%%%%%%%%%% End MAIN %%%%%%%%%%%%%%%%%%%function fdata=writeLine(fdata,cmdList)% fdata.dataout %check content to be written%%% In some uses at least, 'write' appears to be broken: looks like prior%%% lines or cells of a matrix are getting overwritten.%Write a single line of data to a file%fdata = a structure such that%     .fname = the file to create%     .fptr = assigned here, by open cmd%     .formatStr = fprintf C format string%     .dataout = the data to write (single line of text or matrix of numbers)%%cmdList = {'open'} %list of commands to run in sequence on parts of fdata.%%%%for i=1:length(cmdList)    switch cmdList{i}        case 'append' %append numeric matix to existing file            dlmwrite(fdata.fname,fdata.dataout,'-append','delimiter','\t'); %append matrix to text file        case 'open'            fdata.fptr = fopen(fdata.fname,'wt');        case 'write'            fprintf(fdata.fptr,fdata.formatStr,fdata.dataout); %Write single row of data        case 'close'            fclose(fdata.fptr);    end %switch commandsend %for each command in passed listend %fnfunction update_plots(plots,fighandles,scenarios,s)global response x_range threshold hs_ara cl_ara cd_ara fa_ara Splus_distn Sminus_distn hstloc minhotspotloc maxhotspotloc pfa2 yintfigures=fieldnames(fighandles); %list of figure types, set above as field namesfor i=1:length(figures)    figure(fighandles.(char(figures(i)))) %activate specified figure by it's handle number, stored in it's named field    switch char(figures(i))        case 'distributions'            if plots.Splus_distn.on;plot(x_range,Splus_distn,plots.Splus_distn.color,'LineWidth',plots.Splus_distn.linewidth);end%Distn of S+.            if plots.Sminus_distn.on;plot(x_range,Sminus_distn,plots.Sminus_distn.color,'LineWidth',plots.Sminus_distn.linewidth);end%Distn of S-.            if plots.cd_ara.on;plot(x_range,cd_ara,plots.cd_ara.color);end%CDF envelope of S+.            if plots.fa_ara.on;plot(x_range,fa_ara,plots.fa_ara.color);end%CDF envelope of S-.            if plots.cl_ara.on;plot(x_range,cl_ara,plots.cl_ara.color);end%classic util fn            if plots.threshold.on;plot([threshold threshold],[plots.threshold.min plots.threshold.max],plots.threshold.color,'LineWidth',plots.threshold.linewidth);end% threshold            try %hstloc is often zero if muTarget>muFoil due to inflexible coding on my part.                if plots.hstloc.on; plot([hstloc hstloc],[plots.threshold.min plots.threshold.max],plots.threshold.color,'LineWidth',plots.threshold.linewidth);end% threshold as zero of HotSpot fn            end            if plots.hs_ara.on;plot(x_range,hs_ara,plots.hs_ara.color);end%hotspot util fn            if plots.HS_linear_scale.on;plot(x_range,response,plots.HS_linear_scale.color);end%HS response probability gradient (lin scaled HS fn)            if plots.minhotspotloc.on;plot([minhotspotloc minhotspotloc],[plots.minhotspotloc.min plots.minhotspotloc.max],plots.minhotspotloc.color);end% min  of HotSpot fn            if plots.maxhotspotloc.on;plot([maxhotspotloc maxhotspotloc],[plots.maxhotspotloc.min plots.maxhotspotloc.max],plots.maxhotspotloc.color) ;end% max of HotSpot fn                    case 'roc'            if plots.roc.on; plot(fa_ara,cd_ara,'m');end            if plots.indiffence_line.on;plot([0 pfa2],[yint 1],'k');end                            end %switch each figure typeend %for each figure%edit 'unused eqs.m' %to see more plots ideas.end %fn